$comment(-*- coding: utf-8 -*- vim: set encoding=utf-8:)$
Translated by Ye Zheng, Chaofan Jiang

h1. 第十章：解析器

h2. 指南

h3. 解析器的构建

解析器定义在`yacc`源文件`parse.y`中，`yacc`以此生成一个可工作的解析器，`parse.c`。

虽然有人预期有个包含扫描器的`lex.c`，但情况并非如此。这个文件由`gperf`生成的，
它以一个`keywords`文件为输入，定义了一个保留字的hash表。
这个由工具生成的`lex.c``#include`在(也是由工具生成的)`parse.c`中。
现在解释这个过程的细节还有些困难，所以，我们稍后再回过来解释它。

图1展示了解析器的构建过程。那些使用Windows的读者可能不太清楚，
`mv` (移动)命令为文件创建了一个新的拷贝，删除原有的那个。
`cc`当然是C编译器，`cpp`是C的预处理器。

!images/ch_parser_build.png(解析器构建过程)!

h3. 剖析`parse.y`

我们详细的看一下`parse.y`。下面的图粗略地表示`parse.y`的主干。

▼ parse.y 
<pre class="longlist">
%{
header
%}
%union ....
%token ....
%type ....

%%

rules

%%
user code section
    parser interface
    scanner (character stream processing)
    syntax tree construction
    semantic analysis
    local variable management
    ID implementation
</pre>

之前，只是简要的提到过规则和用户代码节。在本章中，我们要开始详细的研究解析器，因此，我们将把注意力转移到这些节上来。

用户代码节中，定义了大量的支撑函数，然而，粗略说来，它们分为六个部分，前面提到过。
下表给出了每个部分在书中何处解释。

|分类|章|节|
|解析器接口|本章|第三节《扫描》|
|扫描器|本章|第三节《扫描》|
|语法树的构建|第十二章《语法树的构建》|第二节《语法树的构建》|
|语意分析|第十二章《语法树的构建》|第三节《语义分析》|
|局部变量管理|第十二章《语法树的构建》|第四节《局部变量》|
|`ID`实现|第三章《名称与名称表》|第二节《`ID`和符号》|

h2. 语法规则总论

h3. 编码规则

`ruby`的语法遵循一定的编码规则，一旦你熟悉了，它就会变得很易读。

先来看看符号命名，所有非终结符都是小写字母。终结符号以某些小写字母作为前缀，后面跟着大写字母。
保留字(关键字)以字母`k`为前缀。其它终结符以字母`t`为前缀。

▼ 符号命名举例

|字符串|符号名|
|(非终结符l)|`bodystmt`|
|`if`|`kIF`|
|`def`|`kDEF`|
|`rescue`|`kRESCUE`|
|`varname`|`tIDENTIFIER`|
|`ConstName`|`tCONST`|
|1|`tINTEGER`|

在这些规则中，唯一例外的是`klBEGIN`和`klEND`。这两个符号名分别对应保留字“BEGIN”和“END”，这里`l`表示`large`。
因为保留字`begin`和`end`已经存在(自然用的是符号名`kBEGIN`和`kEND`，所以需要这些不标准的符号名。

h3. 重要的符号

`parse.y`既包含了语法，也包含了动作，然而，现在，我想把注意力集中在语法规则上。
用脚本sample/exyacc.rb可以从文件中将语法规则提取出来。此外，运行`yacc -v`会产生一个日志文件`y.output`，
其中也包含了语法规则，然而，这个文件相当难读。在本章中，我用一个稍微修改过的`exyacc.rb`来提取语法规则。

▼ `parse.y`(规则)
<pre class="longlist">
program         : compstmt

bodystmt        : compstmt
                  opt_rescue
                  opt_else
                  opt_ensure

compstmt        : stmts opt_terms
                       :
                       :
</pre>

输出相当长，超过450行的语法规则。在本章中，只包含了最重要的部分。

那么，哪些符号才是最重要的呢？比如`program`、`expr`、`stmt`、`primary`、`arg`等符号都是非常重要的。
它们表示了程序设计语言中最常见的语法元素，这些元素将是我们主要关注的。下表列出了这些常见元素和表示它们的符号名。

|语法元素|相关符号名|
|程序|`program prog file input stmts whole`|
|语句|`statement stmt`|
|表达式|`expression expr exp`|
|最小的元素|`primary prim`|
|表达式的左端|`lhs`(left hand side)|
|表达式的右端|`rhs`(right hand side)|
|函数调用|`funcall function_call call function`|
|方法调用|`method method_call call`|
|参数|`argument arg`|
|函数定义|`defun definition function fndef`|
|声明|`declaration decl`|

通常说来，程序设计语言有下面的符号层次关系。

|程序元素|属性|
|语句(statement)|无法与其它符号组合。语法树的主干。|
|表达式(expression)|无法与自身组合，也无法与其它表达式的一部分组合。语法树内部节点。|
|项(Primary)|无法进一步分解的元素。语法树的叶子节点。| 

语句就是类似于C函数定义和Java类定义一样的东西。表达式可能是通常的过程调用，或是数学表达式，等等。
项通常是指字符串常量或是数字等。某些语言并不包含所有这些符号类型，然而，它们通常包含某种类似的符号层次结构：
`program`→`stmt`→`expr`→`primary`。

低层次的符号可以提升至高层次，反之亦然。比如，在C中，函数调用是表达式，也可以是语句。

相反，加了括号的表达式就成为了项。

语句的范围根据语言的不同差别很大。考虑一下赋值。在C中，表达式的值可用于赋值，而在Pascal中，赋值只会用在语句一级。
函数和类定义通常就是语句，而在像Lisp和Scheme这样的语言中，一切都是表达式，它们就也是表达式了。
在这点上，Ruby遵循了Lisp的设计。

h3. 程序结构

那么，将注意力转回`ruby`的语法规则。`yacc`先检查`parse.y`中定义的第一条规则，正如我们可以在下表中看到的，
它是`program`。从这追踪下去，我们可以看出Ruby语法的展开，前面提到的`program stmt expr primary`都在这里出现了。
我们在这还会看到一个额外的规则：`arg`。

▼ `ruby`语法(概要)
<pre class="longlist">
program         : compstmt

compstmt        : stmts opt_terms

stmts           : none
                | stmt
                | stmts terms stmt

stmt            : kALIAS fitem  fitem
                | kALIAS tGVAR tGVAR
                    :
                    :
                | expr

expr            : kRETURN call_args
                | kBREAK call_args
                    :
                    :
                | '!' command_call
                | arg

arg             : lhs '=' arg
                | var_lhs tOP_ASGN arg
                | primary_value '[' aref_args ']' tOP_ASGN arg
                    :
                    :
                | arg '?' arg ':' arg
                | primary

primary         : literal
                | strings
                    :
                    :
                | tLPAREN_ARG expr  ')'
                | tLPAREN compstmt ')'
                    :
                    :
                | kREDO
                | kRETRY
</pre>

关注一下每条规则的最后一项，你就可以清晰看出`program`→`stmt`→`expr`→`arg`→`primary`的层次。

我想关注一下`primary`规则。

<pre class="emlist">
primary         : literal
                    :
                    :
                | tLPAREN_ARG expr  ')'      /* 这里 */
</pre>

`tLPAREN_ARG`中的`t`表示终结符，`L`表示左端，`PAREN`表示括号，也就是说，它表示一个开括号。
为什么不用`‘(’`，我们会在下一章《上下文相关的扫描器》中解释。这条规则的将`expr`退化为`primary`。
图2表示了这一点。从图2可以看出，它创建了一个环，箭头表示在解析期间如何归约。

!images/ch_parser_exprloop.png(`expr`退化)!

下一个规则也特别有趣。

<pre class="emlist">
primary         : literal
                    :
                    :
                | tLPAREN compstmt ')'   /* 这里 */
</pre>

`compstmt`表示整个程序(program)，根据这条归则，它可以退化为`primary`。图3阐释了这条规则。

!images/ch_parser_progloop.png(`program`退化)!

这意味着，Ruby中任何语法元素围上括号，就变成了`primary`，可以作为参数传给函数，
可以用作表达式的右端，等等。看看下面的例子，你就知道是什么意思了。

<pre class="emlist">
p((class C; end))
p((def a() end))
p((alias ali gets))
p((if true then nil else nil end))
p((1 + 1 * 1 ** 1 - 1 / 1 ^ 1))
</pre>

如果我们以`-c`选项(语法检查)调用`ruby`，我们会得到下面的输出。

<pre class="screen">
% ruby -c primprog.rb
Syntax OK
</pre>

虽然初看上去难以接受，不过，在Ruby中确实可以这么做！

我们看语意分析(在第十二章《语法树的构建》”)的时候，会看到这个细节。然而，这条规则有一个很重要的例外。
比如，把`return`语句作为参数传给函数，将会导致错误。“以括号围上任何东西表示它可以作为参数传给函数”，
在大多数情况下都成立。

在下一节中，我会详细的讨论一下最重要的语法规则。

h3. `program`

▼ `program`
<pre class="longlist">
program         : compstmt

compstmt        : stmts opt_terms

stmts           : none
                | stmt
                | stmts terms stmt
</pre>

正如前面提到的，在语法上，`program`表示整个程序。`program`和`compstmts`是相同的，
而`compstmts`几乎等同于`stmts`。`stmts`是以`terms`分割的`stmt`列表。
也就是说整个程序就是以`terms`分割的`stmt`列表。

不用说，`terms`自然是terminators的缩写，语句终结符号，也就是分号及换行符。
`opt_terms`是OPTional `terms`(可省略的`terms`)的意思。它的定义如下：

▼ `opt_terms`
<pre class="longlist">
opt_terms       :
                | terms

terms           : term
                | terms ';'

term            : ';'
                | '\n'
</pre>


因为`terms`是`';'`和`'\n'`后加上任意连续的`';'`，如果只考虑这个规则，两个以上的回车就会出错。实际试一下。

<pre class="emlist">
1 + 1   # 第一个回车
        # 第二个回车
        # 第三个回车
1 + 1
</pre>

再执行一下`ruby -c`。

<pre class="screen">
% ruby -c optterms.rb
Syntax OK
</pre>

奇怪啊！居然通过了。实际上，连续的回车在扫描器的级别就删掉了，传给解析器只是一个回车。

顺便说一下，既然`program`等同于`compstmt`，那为什么还存在这样一个规则呢？实际上，它的存在就是为了执行动作。
比如，`program`就是表示为整个程序做准备，且仅需要进行一次的处理。纯粹从语法角度考虑的话，省略`program`完全没有问题。

将其泛化的话，规则可分为阅读分析必需和执行动作必需两种。`stmts`里的`none`也是一个为了动作而存在的规则，
它为空列表返回(`NODE*`型的)`NULL`指针。

h3. `stmt`

接下来是语句，`stmt`。`stmt`规则的量很大，一点一点的看吧！

▼ `stmt`(1)
<pre class="longlist">
stmt            : kALIAS fitem  fitem
                | kALIAS tGVAR tGVAR
                | kALIAS tGVAR tBACK_REF
                | kALIAS tGVAR tNTH_REF
                | kUNDEF undef_list
                | stmt kIF_MOD expr_value
                | stmt kUNLESS_MOD expr_value
                | stmt kWHILE_MOD expr_value
                | stmt kUNTIL_MOD expr_value
                | stmt kRESCUE_MOD stmt
                | klBEGIN '{' compstmt '}'
                | klEND '{' compstmt '}'
</pre>

很容易理解。开始的几个是`alias`，接下来是`undef`，而后几个连续的“前缀`_MOD`”应该是修饰符（modifier），想来应该是后置语法。

`expr_value`和`primary_value`是为了动作而准备的规则。比如`expr_value`表示有值(value)的`expr`。
没有值的`expr`，是`return`和`break`，以及包含它们的`if`语句等。“有值”的详细定义请参考第12章《构建语法树》。
同样，`primary_value`表示“有值”的`primary`。

`klBEGIN`和`klEND`就是已经解释过的`BEGIN`和`END`。

▼ `stmt`(2)
<pre class="longlist">
                | lhs '=' command_call
                | mlhs '=' command_call
                | var_lhs tOP_ASGN command_call
                | primary_value '[' aref_args ']' tOP_ASGN command_call
                | primary_value '.' tIDENTIFIER tOP_ASGN command_call
                | primary_value '.' tCONSTANT tOP_ASGN command_call
                | primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call
                | backref tOP_ASGN command_call
</pre>

将这些规则放在一起是正确的。共通点在于它们都是右端有`command_call`的赋值。`command_call`是省略参数括号的方法调用。
下表列出了新出现的符号，可以对照着确认一下。

|`lhs`|赋值的左端(Left Hand Side)|
|`mlhs`|多重赋值的左端(Multiple Left Hand Side)|
|`var_lhs`|可变赋值的左端 (VARiable Left Hand Side)|
|`tOP_ASGN`|`+=`和`*=`等组合赋值符号(OPerator ASsiGN)|
|`aref_args`|`[]`用于表示方法调用参数(Array REFerence)|
|`tIDENTIFIER`|用作局部变量的标识符|
|`tCONSTANT`|用作常量的标识符(第一个字母大写)|
|`tCOLON2`|`::`|
|`backref`|`$1 $2 $3...`|

顺便说一下，aref是Lisp的术语。与之对应的aset也是，它是array set的略称。这个缩写在`ruby`源码中的很多地方都用到了。

▼ `stmt`(3)
<pre class="longlist">
                | lhs '=' mrhs_basic
                | mlhs '=' mrhs
</pre>

这两个是多重代入。`mrhs`和`mlhs`有着同样的构造，multiple的`rhs`(右端)。
正如这里所看到的，光看名字的意义就很容易理解。

▼ `stmt`(4)
<pre class="longlist">
                | expr
</pre>

最后，和`expr`联系到一起。

h3. `expr`

▼ `expr`
<pre class="longlist">
expr            : kRETURN call_args
                | kBREAK call_args
                | kNEXT call_args
                | command_call
                | expr kAND expr
                | expr kOR expr
                | kNOT expr
                | '!' command_call
                | arg
</pre>

表达式。`ruby`表达式的语法相当小。

原因是一般情况下归到`expr`几乎都被归到`arg`里去了。其原因是，通常情况下，`expr`几乎都会归结到`arg`。
反过来说，这里还有一些没有归结到`arg`的。谈及剩余的部分，也就是一组省略了括号的方法调用。
`call_args`是剥离出的参数列表，`command_call`是前面提及的省略了括号的方法。
如果将这些放到“小的”单元中，就会产生激烈的冲突。

然而，下面这两个有些不同。

<pre class="emlist">
expr kAND expr
expr kOR expr
</pre>

`kAND`是“`and`”，`kOR`是“`or`”。这两个扮演着控制结构的角色，因此，必须放到`command_call`以上的“大的”语法单元中。
而且，`expr`中有`command_call`。因此，最低限度可以做成`expr`。（＊）比如存在下面这种用法……

<pre class="emlist">
  valid_items.include? arg  or raise ArgumentError, 'invalid arg'
# valid_items.include?(arg) or raise(ArgumentError, 'invalid arg')
</pre>

要是`kAND`规则中用的不是`expr`而是`arg`，就会解释成下面这样：

<pre class="emlist">
valid_items.include?((arg or raise)) ArgumentError, 'invalid arg'
</pre>

当然就是解析错误了！

h3. `arg`

▼ `arg`
<pre class="longlist">
arg             : lhs '=' arg
                | var_lhs tOP_ASGN arg
                | primary_value '[' aref_args ']' tOP_ASGN arg
                | primary_value '.' tIDENTIFIER tOP_ASGN arg
                | primary_value '.' tCONSTANT tOP_ASGN arg
                | primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg
                | backref tOP_ASGN arg
                | arg tDOT2 arg
                | arg tDOT3 arg
                | arg '+' arg
                | arg '-' arg
                | arg '*' arg
                | arg '/' arg
                | arg '%' arg
                | arg tPOW arg
                | tUPLUS arg
                | tUMINUS arg
                | arg '|' arg
                | arg '^' arg
                | arg '&' arg
                | arg tCMP arg
                | arg '>' arg
                | arg tGEQ arg
                | arg '<' arg
                | arg tLEQ arg
                | arg tEQ arg
                | arg tEQQ arg
                | arg tNEQ arg
                | arg tMATCH arg
                | arg tNMATCH arg
                | '!' arg
                | '~' arg
                | arg tLSHFT arg
                | arg tRSHFT arg
                | arg tANDOP arg
                | arg tOROP arg
                | kDEFINED opt_nl  arg
                | arg '?' arg ':' arg
                | primary
</pre>

规则的数量虽然多，但语法的复杂度和规则数量并不成比例。仅仅是情况数量众多的语法对`yacc`来说是很容易处理的，
另一方面，规则递归的深度却会对复杂性有很大的影响。

这样说来，值得注意的是形如`arg OP arg`这样运算符的递归，不过，由于这些运算符都设定了优先级，这里不过是简单枚举罢了。
合并`arg`规则中“简单枚举”，将其剔除。

<pre class="emlist">
arg: lhs '=' arg              /* 1 */
   | primary T_opeq arg       /* 2 */
   | arg T_infix arg          /* 3 */
   | T_pre arg                /* 4 */
   | arg '?' arg ':' arg      /* 5 */
   | primary                  /* 6 */
</pre>

因为终结符和终结符列表没什么区别，这里全部用`T_`前缀表示。`opeq`就是`operator + equal`，`T_pre`表示`'!'`和`'~'`之类前置型的运算符，
`T_infix`表示`'*'`以及`'%'`之类的二元运算符。

为了不和这个结构冲突，以下几点十分重要(但这不是全部)。

* `T_infix`里不含`'='`。

`arg`和`lhs`有部分重叠，如果这里有`'='`，便无法区分规则1和3。

* `T_opeq`和`T_infix`不应有相同的项。

`arg`包含`primary`，如果有相同的项，便无法区分规则2和3。

* `T_infix`里没有`'?'`

如果有的话，规则3和5就会引起shift/reduce conflict。

* `T_pre`不含`'?'`和`':'`

如果有的话，规则4和5就会引起复杂的冲突。

作为结论是由于全部条件成立，这个语法不会冲突。这当然是当然的。

h3. `primary`

`primary`的规则很多，从头开讲。

▼ `primary`(1)
<pre class="longlist">
primary         : literal
                | strings
                | xstring
                | regexp
                | words
                | qwords
</pre>

字面量（literal）类。`literal`包括`Symbol`(`:sym`)和数值。

▼ `primary`(2)
<pre class="longlist">
                | var_ref
                | backref
                | tFID
</pre>

变量类。`var_ref`是局部变量或是实例变量等。`backref`是`$1 $2 $3`……。
`tFID`是包含`!`和`?`的标识符，比如`include? reject!`等。

因为`tFID`不可能是局部变量，即便单独出现，它会在解析器层次上变成方法调用。

▼ `primary`(3)
<pre class="longlist">
                | kBEGIN
                  bodystmt
                  kEND
</pre>

`bodystmt`包括`rescue`和`ensure`，也就是异常控制的`begin`。

▼ `primary`(4)
<pre class="longlist">
                | tLPAREN_ARG expr  ')'
                | tLPAREN compstmt ')'
</pre>

解释过了，语法退化。

▼ `primary`(5)
<pre class="longlist">
                | primary_value tCOLON2 tCONSTANT
                | tCOLON3 cname
</pre>

常量的引用。`tCONSTANT`表示常量名(大写开始的标识符)。

`tCOLON2`和`tCOLON3`虽然都是`::`，不过，`tCOLON3`表示顶层的`::`。
也就是说，`::Const`这种情况的`::`，而`Net::SMTP`的`::`属于`tCOLON2`。

将同样的记号（token）写成不同的符号对应着不同的括号省略方式。比如区别下面这两个。

<pre class="emlist">
p Net::HTTP    # p(Net::HTTP)
p Net  ::HTTP  # p(Net(::HTTP))
</pre>

如果前面有空格或是左括号之类的分隔符，是`tCOLON3`，其它情况是`tCOLON2`。

▼ `primary`(6)
<pre class="longlist">
                | primary_value '[' aref_args ']'
</pre>

索引形式的调用，比如`arr[i]`。

▼ `primary`(7)
<pre class="longlist">
                | tLBRACK aref_args ']'
                | tLBRACE assoc_list '}'
</pre>

数组字面量和hash字面量。这里的`tLBRACK`表示`'['`，这个`'['`前面没有空格，
以此区别省略括号的方法调用。

然而，这个规则的终结符仅相差一个字符，很容易混淆。下表列出了括号的读法，可以进行对照。

▼ 各种括号的英文名

|符号|英文名|中文名|
|`( )`|parentheses|括号、圆括号|
|`{ }`|braces|大括号、花括号|
|`[ ]`|brackets|中括号、方括号|

▼ `primary`(8)
<pre class="longlist">
                | kRETURN
                | kYIELD '(' call_args ')'
                | kYIELD '(' ')'
                | kYIELD
                | kDEFINED opt_nl '('  expr ')'
</pre>

形式与方法调用类似的语法。顺序是`return`、`yield`和`defined?`

为什么`yield`有参数而`return`没有参数？根本的原因在于`yield`会有返回值而`return`没有返回值。
然而，由于这里没有参数，自然就不能传值。`expr`里有下面的规则。

<pre class="emlist">
kRETURN call_args
</pre>

`call_args`是剥离出的参数列表，它可以处理`return 1`和`return nil`。`return(1)`这种形式可以当作`return (1)`处理。
这样说来，下面这样的两个以上的参数`return`是不能加上括号的。

<pre class="emlist">
return(1, 2, 3)   # 解释为return (1,2,3)，解析错误
</pre>

读过下一章《上下文相关的扫描器》，回过头来看这里就可以理解了。

▼ `primary`(9)
<pre class="longlist">
                | operation brace_block
                | method_call
                | method_call brace_block
</pre>

方法调用。`method_call`含有参数（也可以有括号），`operation`既没有括号也没有参数。
`brace_block`就是`{`-`}`或`do`-`end`，带有它的方法就是迭代器。既然是`brace`，为什么会包括`do`-`end`……
这的理由远比Mariana海沟更为深远，关于这点，还是请阅读下一章《上下文相关的扫描器》吧！

▼ `primary`(10)
<pre class="longlist">
  | kIF expr_value then compstmt if_tail kEND         # if
  | kUNLESS expr_value then compstmt opt_else kEND    # unless
  | kWHILE expr_value do compstmt kEND                # while
  | kUNTIL expr_value do compstmt kEND                # until
  | kCASE expr_value opt_terms case_body kEND         # case
  | kCASE opt_terms case_body kEND                    # case(形式2)
  | kFOR block_var kIN expr_value do compstmt kEND    # for
</pre>

基本控制结构。稍有意外的是，如此大的概念居然会放在`primary` 这个“小”东西里面。
因为`primary`也是`arg`，所以可以这样做。

<pre class="emlist">
p(if true then 'ok' end)   # 显示"ok"
</pre>

Ruby的特征之一是“大部分的语法元素都是表达式”。`if`和`while`出现在`primary`里便是具体的表现。

将如此之“大的”语法元素放在`primary`里依然毫无问题，这是因为Ruby语法有“以终结符`A`开始以终结符`B`结束”这一特征。
关于这一点，读过下一节再来考虑。

▼ `primary`(11)
<pre class="longlist">
  | kCLASS cname superclass bodystmt kEND        # 类定义
  | kCLASS tLSHFT expr term bodystmt kEND        # Singleton类定义
  | kMODULE cname bodystmt kEND                  # 模块定义
  | kDEF fname f_arglist bodystmt kEND           # 方法定义
  | kDEF singleton dot_or_colon fname f_arglist bodystmt kEND
                                                 # Singleton方法定义
</pre>

定义语句。类语句虽然称为类语句，但实际上应该称为类节（section）。
因为这些都是“以终结符`A`开始以终结符`B`结束”的模式，加多少都没问题。

▼ `primary`(12)
<pre class="longlist">
                | kBREAK
                | kNEXT
                | kREDO
                | kRETRY
</pre>

各种跳转。从语法上说，这些没有什么。

h3. 冲突列表

前面提到将`if`放到`primary`里，这么做没问题吗？严格论证很困难，但可以直观的简单说明一下。
下面用一个小规则模拟一下。

<pre class="emlist">
%token A B o
%%
element   : A item_list B

item_list :
          | item_list item

item      : element
          | o
</pre>

`element`是下面要讨论问题的关键。比如，考虑`if`时它就是`if`。`element`就是一个以终结符`A`开始以终结符`B`结束的列表。
以`if`来说，就是以`if`开始以`end`结束。其内容中的`o`可以是方法、变量引用或是字面量。
在元素列表中，`o`或`element`可以嵌套。

以此语法为基础做出的解析器，分析下面的输入。

<pre class="emlist">
A  A  o  o  o  B  o  A  o  A  o  o  o  B  o  B  B
</pre>

这里有许多嵌套，没有缩进的帮助便很难理解。像下面这样考虑，就简单多了。
一旦`A`和`B`之间只包含`o`，就可以将它们转化为`o`。只要重复这个过程就可以了。结果如图4所示。

!images/ch_parser_ablist.png(解析“以A开始B结束的列表”的列表)!

但如果结尾没有`B`的话……

<pre class="emlist">
%token A o
%%
element   : A item_list    /* 尝试去掉`B` */

item_list :
          | item_list item

item      : element
          | o
</pre>

用`yacc`处理会产生２个shift/reduce conflicts。也就是说，这个语法是有歧义的。
仅仅去掉上面输入中的`B`，得到下面的输入。

<pre class="emlist">
A  A  o  o  o  o  A  o  A  o  o  o  o
</pre>

怎么都无法理解。当规则有shift/reduce conflits时，应该进行移进，
尝试按规则以移进优先（即内侧优先）进行解析（图5）。

!images/ch_parser_alist.png(解析“以A开始的列表”的列表)!

解析暂时通过了。但结果和意图却完全不同，列表无法在中间切断。

实际上，Ruby中省略括号的方法和这个差不多。有些难以理解的地方是，方法名和第一个参数合起来作为`A`。
因为二者之间没有逗号，可以当作列表的开始识别出来。

此外，“现实中”的 HTML也包含同样的模式。比如，`</p>`和`</li>`可以省略。
正是因为这样，对于普通的的HTML来说，`yacc`根本不能通用。

h2. 扫描器

h3. 解析器概要

在讲扫描器之前，先大致介绍一下解析器。请看图６。

!images/ch_parser_interf.png(解析器接口(调用图))!

解析器的正式接口有三个：`rb_compile_cstr()`、`rb_compile_string()`、`rb_compile_file()`。
分别从C字符串、Ruby字符串对象、Ruby的`IO`对象读入程序进行编译。

这几个函数直接或间接的调用`yycompile()`，最终将控制完全转给`yacc`生成的`yyparse()`。
因为解析器的核心是`yyparse()`，可以以`yyparse()`为中心来把握。
也就是说，`yyparse()`之前运行的函数都是在做准备，而`yyparse()`之后不过些是由`yyparse()`调用的辅助函数。

`parse.y`中剩余的函数是由`yylex()`调用的辅助函数群，这些可以明确地进行分类。

首先，扫描器最低层有个一输入缓冲。在`ruby`源码中，可以从Ruby的`IO`对象或字符串里得到输入，
输入缓冲隐藏了这一差别，假装只有一个单一的字节流。

下一个层次是Token缓冲。从输入缓冲中读出一个一个的字节，在形成一个完整的Token之前，便保留在这里。

`yylex`的整体结构如图7所示。

!images/ch_parser_scanner.png(扫描器的整体图)!

h3. 输入缓冲

首先，从输入缓冲看起。只有三个接口：`nextc()`、`pushback()`和`peek()`。

好象有些乱，先从数据结构看起吧！输入缓冲用到的变量如下。

▼ 输入缓冲
<pre class="longlist">
2279  static char *lex_pbeg;
2280  static char *lex_p;
2281  static char *lex_pend;

(parse.y)
</pre>

缓冲开始、当前以及结束的位置。显然，这个缓冲就是简单的一维字符串缓冲(图8)。

!images/ch_parser_ibuffer.png(输入缓冲)!

h4. `nextc()`

那么，看看用到这些变量的地方吧！最先想到的应该是`nextc()`。

▼ `nextc()`
<pre class="longlist">
2468  static inline int
2469  nextc()
2470  {
2471      int c;
2472
2473      if (lex_p == lex_pend) {
2474          if (lex_input) {
2475              VALUE v = lex_getline();
2476
2477              if (NIL_P(v)) return -1;
2478              if (heredoc_end > 0) {
2479                  ruby_sourceline = heredoc_end;
2480                  heredoc_end = 0;
2481              }
2482              ruby_sourceline++;
2483              lex_pbeg = lex_p = RSTRING(v)->ptr;
2484              lex_pend = lex_p + RSTRING(v)->len;
2485              lex_lastline = v;
2486          }
2487          else {
2488              lex_lastline = 0;
2489              return -1;
2490          }
2491      }
2492      c = (unsigned char)*lex_p++;
2493      if (c == '\r' && lex_p <= lex_pend && *lex_p == '\n') {
2494          lex_p++;
2495          c = '\n';
2496      }
2497
2498      return c;
2499  }

(parse.y)
</pre>

开头的`if`用来判断输入缓冲是否到了最后。至于里面的`if`，可以想见，`else`里返回`-1`（`EOF`）表示输入结束。
反过来说，输入结束时，`lex_input`就变成了0。


这么说吧！输入缓冲是一小段一小段字符串读入的。那单位呢？更新缓冲函数的名字是`lex_getline()`，由此看来，应该是行。

总结一下就是这样。

<pre class="emlist">
if (到达缓冲结尾)
    if (还有输入)
        读取下一行
    else
        return EOF
指针前进
略过CR 
return c
</pre>

看看读取行的函数`lex_getline()`。这里还列出了这个函数用到的变量。

▼ `lex_getline()`
<pre class="longlist">
2276  static VALUE (*lex_gets)();     /* gets function */
2277  static VALUE lex_input;         /* non-nil if File */

2420  static VALUE
2421  lex_getline()
2422  {
2423      VALUE line = (*lex_gets)(lex_input);
2424      if (ruby_debug_lines && !NIL_P(line)) {
2425          rb_ary_push(ruby_debug_lines, line);
2426      }
2427      return line;
2428  }

(parse.y)
</pre>

除了第一行，怎么都好。（*）
`lex_gets`是一个函数指针，用来读取一行，`lex_input`是原始输入。
找一下设置`lex_gets`的地方，在下面。

▼ 设定`lex_gets`
<pre class="longlist">
2430  NODE*
2431  rb_compile_string(f, s, line)
2432      const char *f;
2433      VALUE s;
2434      int line;
2435  {
2436      lex_gets = lex_get_str;
2437      lex_gets_ptr = 0;
2438      lex_input = s;

2454  NODE*
2455  rb_compile_file(f, file, start)
2456      const char *f;
2457      VALUE file;
2458      int start;
2459  {
2460      lex_gets = rb_io_gets;
2461      lex_input = file;

(parse.y)
</pre>

`rb_io_gets()`并非解析器专用，它来自`ruby`通用的程序库，这个函数从`IO`对象中读取一行。

另一个函数`lex_get_str()`，定义如下：

▼ `lex_get_str()`
<pre class="longlist">
2398  static int lex_gets_ptr;

2400  static VALUE
2401  lex_get_str(s)
2402      VALUE s;
2403  {
2404      char *beg, *end, *pend;
2405
2406      beg = RSTRING(s)->ptr;
2407      if (lex_gets_ptr) {
2408          if (RSTRING(s)->len == lex_gets_ptr) return Qnil;
2409          beg += lex_gets_ptr;
2410      }
2411      pend = RSTRING(s)->ptr + RSTRING(s)->len;
2412      end = beg;
2413      while (end < pend) {
2414          if (*end++ == '\n') break;
2415      }
2416      lex_gets_ptr = end - RSTRING(s)->ptr;
2417      return rb_str_new(beg, end - beg);
2418  }

(parse.y)
</pre>

这个函数还不错。`lex_gets_ptr`记录着读到的位置。移动到下一个`\n`，同时截取到那里并返回。

回到`nextc`。准备了两个接口相同的函数，这样在解析器初始化时，可以修改函数指针，而其它的部分则可以共享。
将代码的差异转换为数据的差异，进而吸纳差异。`st_table`中有类似的做法。

h4. `pushback()`

了解过缓冲的物理结构和`nextc()`后，接下来的就简单了。用来写回一个字符的是`pushback()`。
用C的说法，就是`ungetc()`。

▼ `pushback()`
<pre class="longlist">
2501  static void
2502  pushback(c)
2503      int c;
2504  {
2505      if (c == -1) return;
2506      lex_p--;
2507  }

(parse.y)
</pre>

h4. `peek()`

在指针不前进的情况下，检查下面的字符的`peek()`(意思是“窥视”)。

▼ `peek()`
<pre class="longlist">
2509  #define peek(c) (lex_p != lex_pend && (c) == *lex_p)

(parse.y)
</pre>

h3. token缓冲

token缓冲是接下来一级的缓冲。字符串会保存到token取出为止。接口有以下五个。

|`newtok`|新建一个token|
|`tokadd`|向缓冲中加入字符|
|`tokfix`|终结缓存|
|`tok`|指向缓冲字符串开始的指针|
|`toklen`|缓冲字符串长度|
|`toklast`|缓冲的字符串结尾字节|

继续从数据结构开始看起吧！

▼token缓冲
<pre class="longlist">
2271  static char *tokenbuf = NULL;
2272  static int   tokidx, toksiz = 0;

(parse.y)
</pre>

`tokenbuf`是缓冲，`tokidx`是token的结尾(因为是`int`类型，所以象是索引)，`toksiz`是缓冲长度。
它与输入缓冲拥有相同的简单结构。画成图的话，如图9所示。

!images/ch_parser_tbuffer.png(token缓冲)!

继续来看接口，先来看新建token的`newtok()`。

▼ `newtok()`
<pre class="longlist">
2516  static char*
2517  newtok()
2518  {
2519      tokidx = 0;
2520      if (!tokenbuf) {
2521          toksiz = 60;
2522          tokenbuf = ALLOC_N(char, 60);
2523      }
2524      if (toksiz > 4096) {
2525          toksiz = 60;
2526          REALLOC_N(tokenbuf, char, 60);
2527      }
2528      return tokenbuf;
2529  }

(parse.y)
</pre>

