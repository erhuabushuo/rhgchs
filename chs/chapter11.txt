$comment(-*- coding: utf-8 -*- vim: set encoding=utf-8:)$
Translated by Li Linghui, bigpanda

h1. 第十一章：上下文相关的扫描器

h2. 概要

理论上，扫描器只负责切分出记号，解析器只负责处理这个序列，二者完全独立……于所说的阶段就可以了，
这会是一件令人欣慰的事情。可是，现实不会那样美好。需要根据上下文的相关性改变切分记号的方法以及记号本身。
本章讨论的便是扫描器和解析器的合作。

h3. 具体示例

在普通的程序设计语言中，除了切分单词之外，空白没有什么意义。但Ruby有些不寻常，空格有时会完全改变含义。
比如，像下面这种情况。

<pre class="emlist">
a[i] = 1      # a[i] = (1)
a [i]         # a([i])
</pre>

前者是索引赋值，后者是省略了括号的方法调用，传递的参数是数组元素。

还有下面这种情况。

<pre class="emlist">
a  +  1    # (a) + (1)
a  +1      # a(+1)
</pre>

这里的用法过于随意，不太让人喜欢。

但是仅仅这样省略方法括号，似乎会给读者留下了不好的印象，所以，还有另外一个例子。

<pre class="emlist">
`cvs diff parse.y`          # 命令调用的字符串
obj.`("cvs diff parse.y")   # 一般的方法调用
</pre>

这里，前者采用了字面量的形式进行方法调用，而后者用的是一般形式的方法调用（“`”是方法名）。
根据上下文的不同对应的操作也不同。上下文不同，处理会有很大差异。

下面的例子作用上差异极大。

<pre class="emlist">
print(<<EOS)   # here document
......
EOS

list = []
list << nil    # list.push(nil)
</pre>

前者是here-document，后者是运算符形式的方法调用。

像这样的Ruby的语法，确实存在很多实现不是很合适的地方。即便不详细的列举，一章也不介绍不完。
因此，本章的讨论限定在基础原理和难度极高的部分。