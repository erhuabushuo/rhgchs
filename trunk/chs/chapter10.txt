$comment(-*- coding: utf-8 -*- vim: set encoding=utf-8:)$
Translated by Ye Zheng, Chaofan Jiang

h1. 第十章：解析器

h2. 指南

h3. 解析器的构建

解析器定义在`yacc`源文件`parse.y`中，`yacc`以此生成一个可工作的解析器，`parse.c`。

虽然有人预期有个包含扫描器的`lex.c`，但情况并非如此。这个文件由`gperf`生成的，
它以一个`keywords`文件为输入，定义了一个保留字的hash表。
这个由工具生成的`lex.c``#include`在(也是由工具生成的)`parse.c`中。
现在解释这个过程的细节还有些困难，所以，我们稍后再回过来解释它。

图1展示了解析器的构建过程。那些使用Windows的读者可能不太清楚，
`mv` (移动)命令为文件创建了一个新的拷贝，删除原有的那个。
`cc`当然是C编译器，`cpp`是C的预处理器。

!images/ch_parser_build.png(解析器构建过程)!

h3. 剖析`parse.y`

我们详细的看一下`parse.y`。下面的图粗略地表示`parse.y`的主干。

▼ parse.y 
<pre class="longlist">
%{
header
%}
%union ....
%token ....
%type ....

%%

rules

%%
user code section
    parser interface
    scanner (character stream processing)
    syntax tree construction
    semantic analysis
    local variable management
    ID implementation
</pre>

之前，只是简要的提到过规则和用户代码节。在本章中，我们要开始详细的研究解析器，因此，我们将把注意力转移到这些节上来。

用户代码节中，定义了大量的支撑函数，然而，粗略说来，它们分为六个部分，前面提到过。
下表给出了每个部分在书中何处解释。

|分类|章|节|
|解析器接口|本章|第三节《扫描》|
|扫描器|本章|第三节《扫描》|
|语法树的构建|第十二章《语法树的构建》|第二节《语法树的构建》|
|语意分析|第十二章《语法树的构建》|第三节《语义分析》|
|局部变量管理|第十二章《语法树的构建》|第四节《局部变量》|
|`ID`实现|第三章《名称与名称表》|第二节《`ID`和符号》|

h2. 语法规则总论

h3. 编码规则

`ruby`的语法遵循一定的编码规则，一旦你熟悉了，它就会变得很易读。

先来看看符号命名，所有非终结符都是小写字母。终结符号以某些小写字母作为前缀，后面跟着大写字母。
保留字(关键字)以字母`k`为前缀。其它终结符以字母`t`为前缀。

▼ 符号命名举例

|字符串|符号名|
|(非终结符l)|`bodystmt`|
|`if`|`kIF`|
|`def`|`kDEF`|
|`rescue`|`kRESCUE`|
|`varname`|`tIDENTIFIER`|
|`ConstName`|`tCONST`|
|1|`tINTEGER`|

在这些规则中，唯一例外的是`klBEGIN`和`klEND`。这两个符号名分别对应保留字“BEGIN”和“END”，这里`l`表示`large`。
因为保留字`begin`和`end`已经存在(自然用的是符号名`kBEGIN`和`kEND`，所以需要这些不标准的符号名。

h3. 重要的符号

`parse.y`既包含了语法，也包含了动作，然而，现在，我想把注意力集中在语法规则上。
用脚本sample/exyacc.rb可以从文件中将语法规则提取出来。此外，运行`yacc -v`会产生一个日志文件`y.output`，
其中也包含了语法规则，然而，这个文件相当难读。在本章中，我用一个稍微修改过的`exyacc.rb`来提取语法规则。

▼ `parse.y`(规则)
<pre class="longlist">
program         : compstmt

bodystmt        : compstmt
                  opt_rescue
                  opt_else
                  opt_ensure

compstmt        : stmts opt_terms
                       :
                       :
</pre>

输出相当长，超过450行的语法规则。在本章中，只包含了最重要的部分。

那么，哪些符号才是最重要的呢？比如`program`、`expr`、`stmt`、`primary`、`arg`等符号都是非常重要的。
它们表示了程序设计语言中最常见的语法元素，这些元素将是我们主要关注的。下表列出了这些常见元素和表示它们的符号名。

|语法元素|相关符号名|
|程序|`program prog file input stmts whole`|
|语句|`statement stmt`|
|表达式|`expression expr exp`|
|最小的元素|`primary prim`|
|表达式的左端|`lhs`(left hand side)|
|表达式的右端|`rhs`(right hand side)|
|函数调用|`funcall function_call call function`|
|方法调用|`method method_call call`|
|参数|`argument arg`|
|函数定义|`defun definition function fndef`|
|声明|`declaration decl`|

通常说来，程序设计语言有下面的符号层次关系。

|程序元素|属性|
|语句(statement)|无法与其它符号组合。语法树的主干。|
|表达式(expression)|无法与自身组合，也无法与其它表达式的一部分组合。语法树内部节点。|
|项(Primary)|无法进一步分解的元素。语法树的叶子节点。| 

语句就是类似于C函数定义和Java类定义一样的东西。表达式可能是通常的过程调用，或是数学表达式，等等。
项通常是指字符串常量或是数字等。某些语言并不包含所有这些符号类型，然而，它们通常包含某种类似的符号层次结构：
`program`→`stmt`→`expr`→`primary`。

低层次的符号可以提升至高层次，反之亦然。比如，在C中，函数调用是表达式，也可以是语句。

相反，加了括号的表达式就成为了项。

语句的范围根据语言的不同差别很大。考虑一下赋值。在C中，表达式的值可用于赋值，而在Pascal中，赋值只会用在语句一级。
函数和类定义通常就是语句，而在像Lisp和Scheme这样的语言中，一切都是表达式，它们就也是表达式了。
在这点上，Ruby遵循了Lisp的设计。

h3. 程序结构

那么，将注意力转回`ruby`的语法规则。`yacc`先检查`parse.y`中定义的第一条规则，正如我们可以在下表中看到的，
它是`program`。从这追踪下去，我们可以看出Ruby语法的展开，前面提到的`program stmt expr primary`都在这里出现了。
我们在这还会看到一个额外的规则：`arg`。

▼ `ruby`语法(概要)
<pre class="longlist">
program         : compstmt

compstmt        : stmts opt_terms

stmts           : none
                | stmt
                | stmts terms stmt

stmt            : kALIAS fitem  fitem
                | kALIAS tGVAR tGVAR
                    :
                    :
                | expr

expr            : kRETURN call_args
                | kBREAK call_args
                    :
                    :
                | '!' command_call
                | arg

arg             : lhs '=' arg
                | var_lhs tOP_ASGN arg
                | primary_value '[' aref_args ']' tOP_ASGN arg
                    :
                    :
                | arg '?' arg ':' arg
                | primary

primary         : literal
                | strings
                    :
                    :
                | tLPAREN_ARG expr  ')'
                | tLPAREN compstmt ')'
                    :
                    :
                | kREDO
                | kRETRY
</pre>

关注一下每条规则的最后一项，你就可以清晰看出`program`→`stmt`→`expr`→`arg`→`primary`的层次。

我想关注一下`primary`规则。

<pre class="emlist">
primary         : literal
                    :
                    :
                | tLPAREN_ARG expr  ')'      /* 这里 */
</pre>

`tLPAREN_ARG`中的`t`表示终结符，`L`表示左端，`PAREN`表示括号，也就是说，它表示一个开括号。
为什么不用`‘(’`，我们会在下一章《上下文相关的扫描器》中解释。这条规则的将`expr`退化为`primary`。
图2表示了这一点。从图2可以看出，它创建了一个环，箭头表示在解析期间如何归约。

!images/ch_parser_exprloop.png(`expr`退化)!

下一个规则也特别有趣。

<pre class="emlist">
primary         : literal
                    :
                    :
                | tLPAREN compstmt ')'   /* 这里 */
</pre>

`compstmt`表示整个程序(program)，根据这条归则，它可以退化为`primary`。图3阐释了这条规则。

!images/ch_parser_progloop.png(`program`退化)!

这意味着，Ruby中任何语法元素围上括号，就变成了`primary`，可以作为参数传给函数，
可以用作表达式的右端，等等。看看下面的例子，你就知道是什么意思了。

<pre class="emlist">
p((class C; end))
p((def a() end))
p((alias ali gets))
p((if true then nil else nil end))
p((1 + 1 * 1 ** 1 - 1 / 1 ^ 1))
</pre>

如果我们以`-c`选项(语法检查)调用`ruby`，我们会得到下面的输出。

<pre class="screen">
% ruby -c primprog.rb
Syntax OK
</pre>

虽然初看上去难以接受，不过，在Ruby中确实可以这么做！

我们看语意分析(在第十二章《语法树的构建》”)的时候，会看到这个细节。然而，这条规则有一个很重要的例外。
比如，把`return`语句作为参数传给函数，将会导致错误。“以括号围上任何东西表示它可以作为参数传给函数”，
在大多数情况下都成立。

在下一节中，我会详细的讨论一下最重要的语法规则。

h3. `program`

▼ `program`
<pre class="longlist">
program         : compstmt

compstmt        : stmts opt_terms

stmts           : none
                | stmt
                | stmts terms stmt
</pre>

正如前面提到的，在语法上，`program`表示整个程序。`program`和`compstmts`是相同的，
而`compstmts`几乎等同于`stmts`。`stmts`是以`terms`分割的`stmt`列表。
也就是说整个程序就是以`terms`分割的`stmt`列表。

不用说，`terms`自然是terminators的缩写，语句终结符号，也就是分号及换行符。
`opt_terms`是OPTional `terms`(可省略的`terms`)的意思。它的定义如下：

▼ `opt_terms`
<pre class="longlist">
opt_terms       :
                | terms

terms           : term
                | terms ';'

term            : ';'
                | '\n'
</pre>


因为`terms`是`';'`和`'\n'`后加上任意连续的`';'`，如果只考虑这个规则，两个以上的回车就会出错。实际试一下。

<pre class="emlist">
1 + 1   # 第一个回车
        # 第二个回车
        # 第三个回车
1 + 1
</pre>

再执行一下`ruby -c`。

<pre class="screen">
% ruby -c optterms.rb
Syntax OK
</pre>

奇怪啊！居然通过了。实际上，连续的回车在扫描器的级别就删掉了，传给解析器只是一个回车。

顺便说一下，既然`program`等同于`compstmt`，那为什么还存在这样一个规则呢？实际上，它的存在就是为了执行动作。
比如，`program`就是表示为整个程序做准备，且仅需要进行一次的处理。纯粹从语法角度考虑的话，省略`program`完全没有问题。

将其泛化的话，规则可分为阅读分析必需和执行动作必需两种。`stmts`里的`none`也是一个为了动作而存在的规则，
它为空列表返回(`NODE*`型的)`NULL`指针。

h3. `stmt`

接下来是语句，`stmt`。`stmt`规则的量很大，一点一点的看吧！

▼ `stmt`(1)
<pre class="longlist">
stmt            : kALIAS fitem  fitem
                | kALIAS tGVAR tGVAR
                | kALIAS tGVAR tBACK_REF
                | kALIAS tGVAR tNTH_REF
                | kUNDEF undef_list
                | stmt kIF_MOD expr_value
                | stmt kUNLESS_MOD expr_value
                | stmt kWHILE_MOD expr_value
                | stmt kUNTIL_MOD expr_value
                | stmt kRESCUE_MOD stmt
                | klBEGIN '{' compstmt '}'
                | klEND '{' compstmt '}'
</pre>

很容易理解。开始的几个是`alias`，接下来是`undef`，而后几个连续的“前缀`_MOD`”应该是修饰符（modifier），想来应该是后置语法。

`expr_value`和`primary_value`是为了动作而准备的规则。比如`expr_value`表示有值(value)的`expr`。
没有值的`expr`，是`return`和`break`，以及包含它们的`if`语句等。“有值”的详细定义请参考第12章《构建语法树》。
同样，`primary_value`表示“有值”的`primary`。

`klBEGIN`和`klEND`就是已经解释过的`BEGIN`和`END`。

▼ `stmt`(2)
<pre class="longlist">
                | lhs '=' command_call
                | mlhs '=' command_call
                | var_lhs tOP_ASGN command_call
                | primary_value '[' aref_args ']' tOP_ASGN command_call
                | primary_value '.' tIDENTIFIER tOP_ASGN command_call
                | primary_value '.' tCONSTANT tOP_ASGN command_call
                | primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_call
                | backref tOP_ASGN command_call
</pre>

将这些规则放在一起是正确的。共通点在于它们都是右端有`command_call`的赋值。`command_call`是省略参数括号的方法调用。
下表列出了新出现的符号，可以对照着确认一下。

|`lhs`|赋值的左端(Left Hand Side)|
|`mlhs`|多重赋值的左端(Multiple Left Hand Side)|
|`var_lhs`|可变赋值的左端 (VARiable Left Hand Side)|
|`tOP_ASGN`|`+=`和`*=`等组合赋值符号(OPerator ASsiGN)|
|`aref_args`|`[]`用于表示方法调用参数(Array REFerence)|
|`tIDENTIFIER`|用作局部变量的标识符|
|`tCONSTANT`|用作常量的标识符(第一个字母大写)|
|`tCOLON2`|`::`|
|`backref`|`$1 $2 $3...`|

顺便说一下，aref是Lisp的术语。与之对应的aset也是，它是array set的略称。这个缩写在`ruby`源码中的很多地方都用到了。

▼ `stmt`(3)
<pre class="longlist">
                | lhs '=' mrhs_basic
                | mlhs '=' mrhs
</pre>

这两个是多重代入。`mrhs`和`mlhs`有着同样的构造，multiple的`rhs`(右端)。
正如这里所看到的，光看名字的意义就很容易理解。

▼ `stmt`(4)
<pre class="longlist">
                | expr
</pre>

最后，和`expr`联系到一起。

h3. `expr`

▼ `expr`
<pre class="longlist">
expr            : kRETURN call_args
                | kBREAK call_args
                | kNEXT call_args
                | command_call
                | expr kAND expr
                | expr kOR expr
                | kNOT expr
                | '!' command_call
                | arg
</pre>

表达式。`ruby`表达式的语法相当小。

原因是一般情况下归到`expr`几乎都被归到`arg`里去了。其原因是，通常情况下，`expr`几乎都会归结到`arg`。
反过来说，这里还有一些没有归结到`arg`的。谈及剩余的部分，也就是一组省略了括号的方法调用。
`call_args`是剥离出的参数列表，`command_call`是前面提及的省略了括号的方法。
如果将这些放到“小的”单元中，就会产生激烈的冲突。

然而，下面这两个有些不同。

<pre class="emlist">
expr kAND expr
expr kOR expr
</pre>

`kAND`是“`and`”，`kOR`是“`or`”。这两个扮演着控制结构的角色，因此，必须放到`command_call`以上的“大的”语法单元中。
而且，`expr`中有`command_call`。因此，最低限度可以做成`expr`。（＊）比如存在下面这种用法……

<pre class="emlist">
  valid_items.include? arg  or raise ArgumentError, 'invalid arg'
# valid_items.include?(arg) or raise(ArgumentError, 'invalid arg')
</pre>

要是`kAND`规则中用的不是`expr`而是`arg`，就会解释成下面这样：

<pre class="emlist">
valid_items.include?((arg or raise)) ArgumentError, 'invalid arg'
</pre>

当然就是解析错误了！

h3. `arg`

▼ `arg`
<pre class="longlist">
arg             : lhs '=' arg
                | var_lhs tOP_ASGN arg
                | primary_value '[' aref_args ']' tOP_ASGN arg
                | primary_value '.' tIDENTIFIER tOP_ASGN arg
                | primary_value '.' tCONSTANT tOP_ASGN arg
                | primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg
                | backref tOP_ASGN arg
                | arg tDOT2 arg
                | arg tDOT3 arg
                | arg '+' arg
                | arg '-' arg
                | arg '*' arg
                | arg '/' arg
                | arg '%' arg
                | arg tPOW arg
                | tUPLUS arg
                | tUMINUS arg
                | arg '|' arg
                | arg '^' arg
                | arg '&' arg
                | arg tCMP arg
                | arg '>' arg
                | arg tGEQ arg
                | arg '<' arg
                | arg tLEQ arg
                | arg tEQ arg
                | arg tEQQ arg
                | arg tNEQ arg
                | arg tMATCH arg
                | arg tNMATCH arg
                | '!' arg
                | '~' arg
                | arg tLSHFT arg
                | arg tRSHFT arg
                | arg tANDOP arg
                | arg tOROP arg
                | kDEFINED opt_nl  arg
                | arg '?' arg ':' arg
                | primary
</pre>

规则的数量虽然多，但语法的复杂度和规则数量并不成比例。仅仅是情况数量众多的语法对`yacc`来说是很容易处理的，
另一方面，规则递归的深度却会对复杂性有很大的影响。

这样说来，值得注意的是形如`arg OP arg`这样运算符的递归，不过，由于这些运算符都设定了优先级，这里不过是简单枚举罢了。
合并`arg`规则中“简单枚举”，将其剔除。

<pre class="emlist">
arg: lhs '=' arg              /* 1 */
   | primary T_opeq arg       /* 2 */
   | arg T_infix arg          /* 3 */
   | T_pre arg                /* 4 */
   | arg '?' arg ':' arg      /* 5 */
   | primary                  /* 6 */
</pre>

因为终结符和终结符列表没什么区别，这里全部用`T_`前缀表示。`opeq`就是`operator + equal`，`T_pre`表示`'!'`和`'~'`之类前置型的运算符，
`T_infix`表示`'*'`以及`'%'`之类的二元运算符。

为了不和这个结构冲突，以下几点十分重要(但这不是全部)。

* `T_infix`里不含`'='`。

`arg`和`lhs`有部分重叠，如果这里有`'='`，便无法区分规则1和3。

* `T_opeq`和`T_infix`不应有相同的项。

`arg`包含`primary`，如果有相同的项，便无法区分规则2和3。

* `T_infix`里没有`'?'`

如果有的话，规则3和5就会引起shift/reduce conflict。

* `T_pre`不含`'?'`和`':'`

如果有的话，规则4和5就会引起复杂的冲突。

作为结论是由于全部条件成立，这个语法不会冲突。这当然是当然的。

h3. `primary`

`primary`的规则很多，从头开讲。

▼ `primary`(1)
<pre class="longlist">
primary         : literal
                | strings
                | xstring
                | regexp
                | words
                | qwords
</pre>

字面量（literal）类。`literal`包括`Symbol`(`:sym`)和数值。

▼ `primary`(2)
<pre class="longlist">
                | var_ref
                | backref
                | tFID
</pre>

变量类。`var_ref`是局部变量或是实例变量等。`backref`是`$1 $2 $3`……。
`tFID`是包含`!`和`?`的标识符，比如`include? reject!`等。

因为`tFID`不可能是局部变量，即便单独出现，它会在解析器层次上变成方法调用。

▼ `primary`(3)
<pre class="longlist">
                | kBEGIN
                  bodystmt
                  kEND
</pre>

`bodystmt`包括`rescue`和`ensure`，也就是异常控制的`begin`。

▼ `primary`(4)
<pre class="longlist">
                | tLPAREN_ARG expr  ')'
                | tLPAREN compstmt ')'
</pre>

解释过了，语法退化。

▼ `primary`(5)
<pre class="longlist">
                | primary_value tCOLON2 tCONSTANT
                | tCOLON3 cname
</pre>

常量的引用。`tCONSTANT`表示常量名(大写开始的标识符)。

`tCOLON2`和`tCOLON3`虽然都是`::`，不过，`tCOLON3`表示顶层的`::`。
也就是说，`::Const`这种情况的`::`，而`Net::SMTP`的`::`属于`tCOLON2`。

将同样的记号（token）写成不同的符号对应着不同的括号省略方式。比如区别下面这两个。

<pre class="emlist">
p Net::HTTP    # p(Net::HTTP)
p Net  ::HTTP  # p(Net(::HTTP))
</pre>

如果前面有空格或是左括号之类的分隔符，是`tCOLON3`，其它情况是`tCOLON2`。

▼ `primary`(6)
<pre class="longlist">
                | primary_value '[' aref_args ']'
</pre>

索引形式的调用，比如`arr[i]`。

▼ `primary`(7)
<pre class="longlist">
                | tLBRACK aref_args ']'
                | tLBRACE assoc_list '}'
</pre>

数组字面量和hash字面量。这里的`tLBRACK`表示`'['`，这个`'['`前面没有空格，
以此区别省略括号的方法调用。

然而，这个规则的终结符仅相差一个字符，很容易混淆。下表列出了括号的读法，可以进行对照。

▼ 各种括号的英文名

|符号|英文名|中文名|
|`( )`|parentheses|括号、圆括号|
|`{ }`|braces|大括号、花括号|
|`[ ]`|brackets|中括号、方括号|

▼ `primary`(8)
<pre class="longlist">
                | kRETURN
                | kYIELD '(' call_args ')'
                | kYIELD '(' ')'
                | kYIELD
                | kDEFINED opt_nl '('  expr ')'
</pre>

形式与方法调用类似的语法。顺序是`return`、`yield`和`defined?`

为什么`yield`有参数而`return`没有参数？根本的原因在于`yield`会有返回值而`return`没有返回值。
然而，由于这里没有参数，自然就不能传值。`expr`里有下面的规则。

<pre class="emlist">
kRETURN call_args
</pre>

`call_args`是剥离出的参数列表，它可以处理`return 1`和`return nil`。`return(1)`这种形式可以当作`return (1)`处理。
这样说来，下面这样的两个以上的参数`return`是不能加上括号的。

<pre class="emlist">
return(1, 2, 3)   # 解释为return (1,2,3)，解析错误
</pre>

读过下一章《上下文相关的扫描器》，回过头来看这里就可以理解了。

▼ `primary`(9)
<pre class="longlist">
                | operation brace_block
                | method_call
                | method_call brace_block
</pre>

方法调用。`method_call`含有参数（也可以有括号），`operation`既没有括号也没有参数。
`brace_block`就是`{`-`}`或`do`-`end`，带有它的方法就是迭代器。既然是`brace`，为什么会包括`do`-`end`……
这的理由远比Mariana海沟更为深远，关于这点，还是请阅读下一章《上下文相关的扫描器》吧！

▼ `primary`(10)
<pre class="longlist">
  | kIF expr_value then compstmt if_tail kEND         # if
  | kUNLESS expr_value then compstmt opt_else kEND    # unless
  | kWHILE expr_value do compstmt kEND                # while
  | kUNTIL expr_value do compstmt kEND                # until
  | kCASE expr_value opt_terms case_body kEND         # case
  | kCASE opt_terms case_body kEND                    # case(形式2)
  | kFOR block_var kIN expr_value do compstmt kEND    # for
</pre>

基本控制结构。稍有意外的是，如此大的概念居然会放在`primary` 这个“小”东西里面。
因为`primary`也是`arg`，所以可以这样做。

<pre class="emlist">
p(if true then 'ok' end)   # 显示"ok"
</pre>

Ruby的特征之一是“大部分的语法元素都是表达式”。`if`和`while`出现在`primary`里便是具体的表现。

将如此之“大的”语法元素放在`primary`里依然毫无问题，这是因为Ruby语法有“以终结符`A`开始以终结符`B`结束”这一特征。
关于这一点，读过下一节再来考虑。

▼ `primary`(11)
<pre class="longlist">
  | kCLASS cname superclass bodystmt kEND        # 类定义
  | kCLASS tLSHFT expr term bodystmt kEND        # Singleton类定义
  | kMODULE cname bodystmt kEND                  # 模块定义
  | kDEF fname f_arglist bodystmt kEND           # 方法定义
  | kDEF singleton dot_or_colon fname f_arglist bodystmt kEND
                                                 # Singleton方法定义
</pre>

定义语句。类语句虽然称为类语句，但实际上应该称为类节（section）。
因为这些都是“以终结符`A`开始以终结符`B`结束”的模式，加多少都没问题。

▼ `primary`(12)
<pre class="longlist">
                | kBREAK
                | kNEXT
                | kREDO
                | kRETRY
</pre>

各种跳转。从语法上说，这些没有什么。

h3. 冲突列表

前面提到将`if`放到`primary`里，这么做没问题吗？严格论证很困难，但可以直观的简单说明一下。
下面用一个小规则模拟一下。

<pre class="emlist">
%token A B o
%%
element   : A item_list B

item_list :
          | item_list item

item      : element
          | o
</pre>

`element`是下面要讨论问题的关键。比如，考虑`if`时它就是`if`。`element`就是一个以终结符`A`开始以终结符`B`结束的列表。
以`if`来说，就是以`if`开始以`end`结束。其内容中的`o`可以是方法、变量引用或是字面量。
在元素列表中，`o`或`element`可以嵌套。

以此语法为基础做出的解析器，分析下面的输入。

<pre class="emlist">
A  A  o  o  o  B  o  A  o  A  o  o  o  B  o  B  B
</pre>

这里有许多嵌套，没有缩进的帮助便很难理解。像下面这样考虑，就简单多了。
一旦`A`和`B`之间只包含`o`，就可以将它们转化为`o`。只要重复这个过程就可以了。结果如图4所示。

!images/ch_parser_ablist.png(解析“以A开始B结束的列表”的列表)!

但如果结尾没有`B`的话……

<pre class="emlist">
%token A o
%%
element   : A item_list    /* 尝试去掉`B` */

item_list :
          | item_list item

item      : element
          | o
</pre>

用`yacc`处理会产生２个shift/reduce conflicts。也就是说，这个语法是有歧义的。
仅仅去掉上面输入中的`B`，得到下面的输入。

<pre class="emlist">
A  A  o  o  o  o  A  o  A  o  o  o  o
</pre>

怎么都无法理解。当规则有shift/reduce conflits时，应该进行移进，
尝试按规则以移进优先（即内侧优先）进行解析（图5）。

!images/ch_parser_alist.png(解析“以A开始的列表”的列表)!

解析暂时通过了。但结果和意图却完全不同，列表无法在中间切断。

实际上，Ruby中省略括号的方法和这个差不多。有些难以理解的地方是，方法名和第一个参数合起来作为`A`。
因为二者之间没有逗号，可以当作列表的开始识别出来。

此外，“现实中”的 HTML也包含同样的模式。比如，`</p>`和`</li>`可以省略。
正是因为这样，对于普通的的HTML来说，`yacc`根本不能通用。

h2. 扫描器

h3. 解析器概要

在讲扫描器之前，先大致介绍一下解析器。请看图６。

!images/ch_parser_interf.png(解析器接口(调用图))!

解析器的正式接口有三个：`rb_compile_cstr()`、`rb_compile_string()`、`rb_compile_file()`。
分别从C字符串、Ruby字符串对象、Ruby的`IO`对象读入程序进行编译。

这几个函数直接或间接的调用`yycompile()`，最终将控制完全转给`yacc`生成的`yyparse()`。
因为解析器的核心是`yyparse()`，可以以`yyparse()`为中心来把握。
也就是说，`yyparse()`之前运行的函数都是在做准备，而`yyparse()`之后不过些是由`yyparse()`调用的辅助函数。

`parse.y`中剩余的函数是由`yylex()`调用的辅助函数群，这些可以明确地进行分类。

首先，扫描器最低层有个一输入缓冲。在`ruby`源码中，可以从Ruby的`IO`对象或字符串里得到输入，
输入缓冲隐藏了这一差别，假装只有一个单一的字节流。

下一个层次是Token缓冲。从输入缓冲中读出一个一个的字节，在形成一个完整的Token之前，便保留在这里。

`yylex`的整体结构如图7所示。

!images/ch_parser_scanner.png(扫描器的整体图)!

h3. 输入缓冲

首先，从输入缓冲看起。只有三个接口：`nextc()`、`pushback()`和`peek()`。

好象有些乱，先从数据结构看起吧！输入缓冲用到的变量如下。

▼ 输入缓冲
<pre class="longlist">
2279  static char *lex_pbeg;
2280  static char *lex_p;
2281  static char *lex_pend;

(parse.y)
</pre>

缓冲开始、当前以及结束的位置。显然，这个缓冲就是简单的一维字符串缓冲(图8)。

!images/ch_parser_ibuffer.png(输入缓冲)!

h4. `nextc()`

那么，看看用到这些变量的地方吧！最先想到的应该是`nextc()`。

▼ `nextc()`
<pre class="longlist">
2468  static inline int
2469  nextc()
2470  {
2471      int c;
2472
2473      if (lex_p == lex_pend) {
2474          if (lex_input) {
2475              VALUE v = lex_getline();
2476
2477              if (NIL_P(v)) return -1;
2478              if (heredoc_end > 0) {
2479                  ruby_sourceline = heredoc_end;
2480                  heredoc_end = 0;
2481              }
2482              ruby_sourceline++;
2483              lex_pbeg = lex_p = RSTRING(v)->ptr;
2484              lex_pend = lex_p + RSTRING(v)->len;
2485              lex_lastline = v;
2486          }
2487          else {
2488              lex_lastline = 0;
2489              return -1;
2490          }
2491      }
2492      c = (unsigned char)*lex_p++;
2493      if (c == '\r' && lex_p <= lex_pend && *lex_p == '\n') {
2494          lex_p++;
2495          c = '\n';
2496      }
2497
2498      return c;
2499  }

(parse.y)
</pre>

开头的`if`用来判断输入缓冲是否到了最后。至于里面的`if`，可以想见，`else`里返回`-1`（`EOF`）表示输入结束。
反过来说，输入结束时，`lex_input`就变成了0。


这么说吧！输入缓冲是一小段一小段字符串读入的。那单位呢？更新缓冲函数的名字是`lex_getline()`，由此看来，应该是行。

总结一下就是这样。

<pre class="emlist">
if (到达缓冲结尾)
    if (还有输入)
        读取下一行
    else
        return EOF
指针前进
略过CR 
return c
</pre>

看看读取行的函数`lex_getline()`。这里还列出了这个函数用到的变量。

▼ `lex_getline()`
<pre class="longlist">
2276  static VALUE (*lex_gets)();     /* gets function */
2277  static VALUE lex_input;         /* non-nil if File */

2420  static VALUE
2421  lex_getline()
2422  {
2423      VALUE line = (*lex_gets)(lex_input);
2424      if (ruby_debug_lines && !NIL_P(line)) {
2425          rb_ary_push(ruby_debug_lines, line);
2426      }
2427      return line;
2428  }

(parse.y)
</pre>

除了第一行，怎么都好。（*）
`lex_gets`是一个函数指针，用来读取一行，`lex_input`是原始输入。
找一下设置`lex_gets`的地方，在下面。

▼ 设定`lex_gets`
<pre class="longlist">
2430  NODE*
2431  rb_compile_string(f, s, line)
2432      const char *f;
2433      VALUE s;
2434      int line;
2435  {
2436      lex_gets = lex_get_str;
2437      lex_gets_ptr = 0;
2438      lex_input = s;

2454  NODE*
2455  rb_compile_file(f, file, start)
2456      const char *f;
2457      VALUE file;
2458      int start;
2459  {
2460      lex_gets = rb_io_gets;
2461      lex_input = file;

(parse.y)
</pre>

`rb_io_gets()`并非解析器专用，它来自`ruby`通用的程序库，这个函数从`IO`对象中读取一行。

另一个函数`lex_get_str()`，定义如下：

▼ `lex_get_str()`
<pre class="longlist">
2398  static int lex_gets_ptr;

2400  static VALUE
2401  lex_get_str(s)
2402      VALUE s;
2403  {
2404      char *beg, *end, *pend;
2405
2406      beg = RSTRING(s)->ptr;
2407      if (lex_gets_ptr) {
2408          if (RSTRING(s)->len == lex_gets_ptr) return Qnil;
2409          beg += lex_gets_ptr;
2410      }
2411      pend = RSTRING(s)->ptr + RSTRING(s)->len;
2412      end = beg;
2413      while (end < pend) {
2414          if (*end++ == '\n') break;
2415      }
2416      lex_gets_ptr = end - RSTRING(s)->ptr;
2417      return rb_str_new(beg, end - beg);
2418  }

(parse.y)
</pre>

这个函数还不错。`lex_gets_ptr`记录着读到的位置。移动到下一个`\n`，同时截取到那里并返回。

回到`nextc`。准备了两个接口相同的函数，这样在解析器初始化时，可以修改函数指针，而其它的部分则可以共享。
将代码的差异转换为数据的差异，进而吸纳差异。`st_table`中有类似的做法。

h4. `pushback()`

了解过缓冲的物理结构和`nextc()`后，接下来的就简单了。用来写回一个字符的是`pushback()`。
用C的说法，就是`ungetc()`。

▼ `pushback()`
<pre class="longlist">
2501  static void
2502  pushback(c)
2503      int c;
2504  {
2505      if (c == -1) return;
2506      lex_p--;
2507  }

(parse.y)
</pre>

h4. `peek()`

在指针不前进的情况下，检查下面的字符的`peek()`(意思是“窥视”)。

▼ `peek()`
<pre class="longlist">
2509  #define peek(c) (lex_p != lex_pend && (c) == *lex_p)

(parse.y)
</pre>

h3. token缓冲

token缓冲是接下来一级的缓冲。字符串会保存到token取出为止。接口有以下五个。

|`newtok`|新建一个token|
|`tokadd`|向缓冲中加入字符|
|`tokfix`|终结缓存|
|`tok`|指向缓冲字符串开始的指针|
|`toklen`|缓冲字符串长度|
|`toklast`|缓冲的字符串结尾字节|

继续从数据结构开始看起吧！

▼token缓冲
<pre class="longlist">
2271  static char *tokenbuf = NULL;
2272  static int   tokidx, toksiz = 0;

(parse.y)
</pre>

`tokenbuf`是缓冲，`tokidx`是token的结尾(因为是`int`类型，所以象是索引)，`toksiz`是缓冲长度。
它与输入缓冲拥有相同的简单结构。画成图的话，如图9所示。

!images/ch_parser_tbuffer.png(token缓冲)!

继续来看接口，先来看新建token的`newtok()`。

▼ `newtok()`
<pre class="longlist">
2516  static char*
2517  newtok()
2518  {
2519      tokidx = 0;
2520      if (!tokenbuf) {
2521          toksiz = 60;
2522          tokenbuf = ALLOC_N(char, 60);
2523      }
2524      if (toksiz > 4096) {
2525          toksiz = 60;
2526          REALLOC_N(tokenbuf, char, 60);
2527      }
2528      return tokenbuf;
2529  }

(parse.y)
</pre>

因为不存在对整个缓冲进行初始化的接口，所以，缓冲有可能没有初始化。因此，
最开始的`if`完成检查并初始化。`ALLOC_N()`是`ruby`定义的一个宏，与`calloc()`大致相同。

分配长度的初始值是60，如果变得过大（`> 4096`），则返回一个小的值。
一个token不可能有这么长，所以，这个大小是切合实际的。

接下来看看向token缓冲中添加字符的`tokadd()`。

▼ `tokadd()`
<pre class="longlist">
2531  static void
2532  tokadd(c)
2533      char c;
2534  {
2535      tokenbuf[tokidx++] = c;
2536      if (tokidx >= toksiz) {
2537          toksiz *= 2;
2538          REALLOC_N(tokenbuf, char, toksiz);
2539      }
2540  }

(parse.y)
</pre>

在一行里添加字符。检查token长度，超出缓冲的话，就做`REALLOC_N()`。
`REALLOC_N()`指定参数的方式，就好象"与`calloc()`相同的"`realloc()`一样。

这里总结了其余的接口。

▼ `tokfix() tok() toklen() toklast()`
<pre class="longlist">
2511  #define tokfix() (tokenbuf[tokidx]='\0')
2512  #define tok() tokenbuf
2513  #define toklen() tokidx
2514  #define toklast() (tokidx>0?tokenbuf[tokidx-1]:0)

(parse.y)
</pre>

没有问题吧！

h3. `yylex()`

`yylex()`非常长。现在就有1000行以上。它的主体就是一个巨大的`switch`结构，根据字符选择不同的分支。
先来看看省略一部分后的整体结构。

▼ `yylex`概要
<pre class="longlist">
3106  static int
3107  yylex()
3108  {
3109      static ID last_id = 0;
3110      register int c;
3111      int space_seen = 0;
3112      int cmd_state;
3113
3114      if (lex_strterm) {
              /* ……字符串的扫描…… */
3131          return token;
3132      }
3133      cmd_state = command_start;
3134      command_start = Qfalse;
3135    retry:
3136      switch (c = nextc()) {
3137        case '\0':                /* NUL */
3138        case '\004':              /* ^D */
3139        case '\032':              /* ^Z */
3140        case -1:                  /* end of script. */
3141          return 0;
3142
3143          /* white spaces */
3144        case ' ': case '\t': case '\f': case '\r':
3145        case '\13': /* '\v' */
3146          space_seen++;
3147          goto retry;
3148
3149        case '#':         /* it's a comment */
3150          while ((c = nextc()) != '\n') {
3151              if (c == -1)
3152                  return 0;
3153          }
3154          /* fall through */
3155        case '\n':
              /* ……省略…… */

            case xxxx:
                :
              break;
                :
            /* 很多字符分支 */
                :
                :
4103        default:
4104          if (!is_identchar(c) || ISDIGIT(c)) {
4105              rb_compile_error("Invalid char `\\%03o' in expression", c);
4106              goto retry;
4107          }
4108
4109          newtok();
4110          break;
4111      }

          /* ……处理通常的标识符…… */
      }

(parse.y)
</pre>

`yylex()`的返回值零表示“输入结束”，非零表示token。

请注意，“`c`”等非常简洁的变量在整体上的运用。读空格时的`space_seen++`会在后面用到。

接下来就是根据字符不同进行分支处理，都是些单调的处理，读起来很枯燥。所以，缩小范围只看几个点。
本书没有讲到所有的字符，不过，同样模式的都进行了简要的说明。

h4. `'!'`

先来看个简单的。

▼ `yylex`-`'!'`
<pre class="longlist">
3205        case '!':
3206          lex_state = EXPR_BEG;
3207          if ((c = nextc()) == '=') {
3208              return tNEQ;
3209          }
3210          if (c == '~') {
3211              return tNMATCH;
3212          }
3213          pushback(c);
3214          return '!';

(parse.y)
</pre>

将代码的意思用文字写下来，可以对着读一下。

<pre class="emlist">
case '!':
  状态转到EXPR_BEG 
  if (下一字符是'=') {
      token是'!='（tNEQ）
  }
  if (下一字符是'~') {
      token是'!~'（tNMATCH）
  }
  若都是的话，退回一个已读的字符
  token是'!'
</pre>

这个`case`很短，但依然能够展现出扫描器的重要规则，即“最长一致原则”。`“!=”`这两个字符有两种解释：
“`!`和`=`”，
或是“`!=`”。
这里这种情况，必须选择`!=`。
最长一致是程序语言扫描器的基本要求。

`lex_state`是表示扫描器状态的变量。在下一章《上下文相关的扫描器》中，会讲到让你厌烦，这里就暂时忽略它。
这里只要说一件事，很明显，`EXPR_BEG`表示“表达式开始”。无论是`not`、
`!=`还是
`!~`中的
`!`，都是表达式的开始。

h4. `'>'`

接下来，作为`yylval`(符号的值)的例子，我们来看看`'>'`。

▼ `yylex`-`'>'`
<pre class="longlist">
3296        case '>':
3297          switch (lex_state) {
3298            case EXPR_FNAME: case EXPR_DOT:
3299              lex_state = EXPR_ARG; break;
3300            default:
3301              lex_state = EXPR_BEG; break;
3302          }
3303          if ((c = nextc()) == '=') {
3304              return tGEQ;
3305          }
3306          if (c == '>') {
3307              if ((c = nextc()) == '=') {
3308                  yylval.id = tRSHFT;
3309                  lex_state = EXPR_BEG;
3310                  return tOP_ASGN;
3311              }
3312              pushback(c);
3313              return tRSHFT;
3314          }
3315          pushback(c);
3316          return '>';

(parse.y)
</pre>
	
忽略`yylval`以外的情况。阅读程序时，很重要的一点就是只关注一件事。

`>=`对应于符号`tOP_ASGN`，这里将其值设为`tRSHFT`。这里用到的公用体成员是`id`，所以其类型应该是`ID`。
`tOP_ASGN`是自赋值的符号，象`+=`、`-=`和`*=`等都会归结起来用它表示。那么，接下来就该区分什么样的自赋值作为值传了进去。

为什么要把自赋值归结到一起呢，因为这样可以将规则变短。在扫描器中，很多有可能归结起来的都归结到了一起，
这样，可以让规则很精简。那么为什么不将二元操作符归结到一起呢，这是因为它们的优先级不同。

h4. `':'`

如果扫描器能够完全独立于解析器，那就很简单了，可现实并不会这么简单。

Ruby的语法特别复杂，会因为前面是否有空格而不同，也会因为周围切分token的状况而变化。
下面的`':'`代码就是一个空格影响行为的例子。

▼ `yylex`-`':'`
<pre class="longlist">
3761        case ':':
3762          c = nextc();
3763          if (c == ':') {
3764              if (lex_state == EXPR_BEG ||  lex_state == EXPR_MID ||
3765                  (IS_ARG() && space_seen)) {
3766                  lex_state = EXPR_BEG;
3767                  return tCOLON3;
3768              }
3769              lex_state = EXPR_DOT;
3770              return tCOLON2;
3771          }
3772          pushback(c);
3773          if (lex_state == EXPR_END ||
                  lex_state == EXPR_ENDARG ||
                  ISSPACE(c)) {
3774              lex_state = EXPR_BEG;
3775              return ':';
3776          }
3777          lex_state = EXPR_FNAME;
3778          return tSYMBEG;

(parse.y)
</pre>

这次忽略`lex_state`，只要关注`space_seen`的周围就可以了。

`space_seen`是这样一个变量，token前如果有空格就为真。如果它为真，也就是说`'::'`前面有空格，结果就是`tCOLON3`，
前面没有空格的话，就是`tCOLON2`。这和前一节`primary`里的说明是一致的。

h4. 标识符

目前为止，看到的符号最多只有一两个字符，现在就来看看稍长一点的东西吧。标识符的扫描模式。

先来看看`yylex`的整体结构。

<pre class="emlist">
yylex(...)
{
    switch (c = nextc()) {
      case xxxx:
        ....
      case xxxx:
        ....
      default:
    }

    扫描标识符的代码
}
</pre>

接下来的代码引用自那个巨型`switch`结尾的部分。稍有些长，加了些注释。

▼ `yylex`-标识符
<pre class="longlist">
4081        case '@':                 /* 实例变量或类变量 */
4082          c = nextc();
4083          newtok();
4084          tokadd('@');
4085          if (c == '@') {         /* @@、也就是类变量 */
4086              tokadd('@');
4087              c = nextc();
4088          }
4089          if (ISDIGIT(c)) {       /* @1等 */
4090              if (tokidx == 1) {
4091    rb_compile_error("`@%c' is not a valid instance variable name", c);
4092              }
4093              else {
4094    rb_compile_error("`@@%c' is not a valid class variable name", c);
4095              }
4096          }
4097          if (!is_identchar(c)) { /* @后面是奇怪的字符 */
4098              pushback(c);
4099              return '@';
4100          }
4101          break;
4102
4103        default:
4104          if (!is_identchar(c) || ISDIGIT(c)) {
4105              rb_compile_error("Invalid char `\\%03o' in expression", c);
4106              goto retry;
4107          }
4108
4109          newtok();
4110          break;
4111      }
4112
4113      while (is_identchar(c)) {   /* 标识符中能够使用的字符…… */
4114          tokadd(c);
4115          if (ismbchar(c)) {      /* 如果是多字节字符的开始字节 */
4116              int i, len = mbclen(c)-1;
4117
4118              for (i = 0; i < len; i++) {
4119                  c = nextc();
4120                  tokadd(c);
4121              }
4122          }
4123          c = nextc();
4124      }
4125      if ((c == '!' || c == '?') &&
              is_identchar(tok()[0]) &&
              !peek('=')) {      /* name!或是name?的结尾字符 */
4126          tokadd(c);
4127      }
4128      else {
4129          pushback(c);
4130      }
4131      tokfix();

(parse.y)
</pre>

请注意最后添加`!`/`?`的条件。这部分是为了解释下面这种情况。

<pre class="emlist">
obj.m=1       # obj.m  =   1       (而不是obj.m= ...)
obj.m!=1      # obj.m  !=  1       (而不是obj.m! ...)
</pre>

也就是说，“不是”最长一致。最长一致只是原则而非规则，所以，有时可能会违背。

h4. 保留字

扫描过标识符之后，其实还有100行左右的代码，那里才会得出实际的token。
之前的代码是把实例变量、类变量和局部变量一起扫描的，这里要重新分类。

这还不错，不过，有一些项稍有不同。那就是要将保留字筛选出来。保留字和局部变量没什么区别，
所以，一起扫描之后再分类会更高效。

那么，对于`char*`类型的字符串`str`，如何区分它是不是保留字呢？首先，我们当然可以用`if`和`strcmp()`不断地比较。
不过这种做法很不聪明。没有弹性。速度也会线性增加。

通常的做法是，把数据放到列表或hash表中，这样完成的代码就会很短。

<pre class="emlist">
/* 将代码转换为数据 */
struct entry {char *name; int symbol;};
struct entry *table[] = {
    {"if",     kIF},
    {"unless", kUNLESS},
    {"while",  kWHILE},
    /* ……省略…… */
};

{
    ....
    return lookup_symbol(table, tok());
}
</pre>

`ruby`是怎么做的呢？用hash表。它也是一个完全hash表。谈及`st_table`时说过，如果能够预先知道键值可能的集合，
就可以做出完全没有冲突的hash函数。保留字刚好是“能够预先知道键值可能的集合”，所以，可以做成完全hash函数。

但是“可以做”和实际做是两码事。不可能手工做这件事。保留字可能会增加或减少，所以，这个工作必须自动化。

这里用的是`gperf`。`gperf`是一个GNU的程序，它根据一个值的集合生成完全哈希函数。
关于`gperf`自身详细的用法可以用`man gperf`命令得到，这里只说明如何使用生成的结果。

在`ruby`中，`gperf`的输入文件是`keywords`，输出是`lex.c`。`parse.y`直接`#include`进来。
一般来说，将C文件`#include`进来并不好，为了一个根本不能分割的函数分出一个文件更加不值得。
特别是在`ruby`里，`extern`函数不知什么时候可能会被扩展程序库用到，所以，对于那些不想保持兼容性的函数，
尽可能做成`static`。

`lex.c`定义了`rb_reserved_word()`这个函数。用保留字的`char*`指针作为键值进行检索。
就返回值来说，找不到返回`NULL`，找到（也就是说参数是保留字），返回一个`struct kwtable*`指针。
`struct kwtable`的定义如下。

▼ `kwtable`
<pre class="longlist">
   1  struct kwtable {char *name; int id[2]; enum lex_state state;};

(keywords)
</pre>

`name`是保留字的字面量，`id[0]`是那个token，`id[1]`是用作修饰符的token(`kIF_MOD`等)。
`lex_state`是“读取保留字之后应该转移到的`lex_state`”。`lex_state`将在下一章说明。
实际上，检索就在这附近。

▼ `yylex()`-标识符-调用`rb_reserved_word()`
<pre class="longlist">
4173                  struct kwtable *kw;
4174
4175                  /* See if it is a reserved word.  */
4176                  kw = rb_reserved_word(tok(), toklen());
4177                  if (kw) {

(parse.y)
</pre>

h3. 字符串类

如果`yylex()`看到双引号（`“`），会变成这样。

▼ `yylex`-`'"'`
<pre class="longlist">
3318        case '"':
3319          lex_strterm = NEW_STRTERM(str_dquote, '"', 0);
3320          return tSTRING_BEG;

(parse.y)
</pre>

只扫描一个字符就结束了。看一下规则的话，会在下面的规则中找到`tSTRING_BEG`。

▼ 字符串相关的规则
<pre class="longlist">
string1         : tSTRING_BEG string_contents tSTRING_END

string_contents :
                | string_contents string_content

string_content  : tSTRING_CONTENT
                | tSTRING_DVAR string_dvar
                | tSTRING_DBEG term_push compstmt '}'

string_dvar     : tGVAR
                | tIVAR
                | tCVAR
                | backref

term_push       :
</pre>

这些规则是为了对应在字符串中嵌入表达式而引入的。`tSTRING_CONTENT`是字面量部分，
`tSTRING_DBEG`就是`"#{"`。`tSTRING_DVAR`表示“跟着变量的`#`”。比如

<pre class="emlist">
".....#$gvar...."
</pre>

是这样的语法结构。没说明的情况下，如果嵌入的只是一个变量，可以省略`{`和`}`。但不推荐这么做。
顺便说一下，一般认为`DVAR`、`DBEG`的`D`是`dynamic`的缩写。

另外，`backref`表示`$1 $2`和`$& $'`之类与正则表达式有关的特殊变量。

`term_push`是“一个动作规则”。

那么，回到`yylex()`。简单的回到解析器中，上下文应该是在字符串“中”。接下来，`yylex()`扫描出变量、`if`之类的，
就会很麻烦。因此，就要做很重要的工作……

<pre class="emlist">
      case '"':
        lex_strterm = NEW_STRTERM(str_dquote, '"', 0);
        return tSTRING_BEG;
</pre>

……就是`lex_strterm`。回到`yylex()`的开始。

▼ `yylex()`开始
<pre class="longlist">
3106  static int
3107  yylex()
3108  {
3109      static ID last_id = 0;
3110      register int c;
3111      int space_seen = 0;
3112      int cmd_state;
3113
3114      if (lex_strterm) {
              /* ……字符串的扫描…… */
3131          return token;
3132      }
3133      cmd_state = command_start;
3134      command_start = Qfalse;
3135    retry:
3136      switch (c = nextc()) {

(parse.y)
</pre>

如果存在`lex_strterm`，不用说，进入了字符串模式。反过来说，`lex_strterm`存在时，正在扫描字符串，
不过，处理嵌入表达式时，必须先将`lex_strterm`置0.。并且，必须在结束嵌入表达式处理时返还。
下面便是做这个的部分。

▼ `string_content`
<pre class="longlist">
1916  string_content  : ....
1917                  | tSTRING_DBEG term_push
1918                      {
1919                          $<num>1 = lex_strnest;
1920                          $<node>$ = lex_strterm;
1921                          lex_strterm = 0;
1922                          lex_state = EXPR_BEG;
1923                      }
1924                    compstmt '}'
1925                      {
1926                          lex_strnest = $<num>1;
1927                          quoted_term = $2;
1928                          lex_strterm = $<node>3;
1929                          if (($$ = $4) && nd_type($$) == NODE_NEWLINE) {
1930                              $$ = $$->nd_next;
1931                              rb_gc_force_recycle((VALUE)$4);
1932                          }
1933                          $$ = NEW_EVSTR($$);
1934                      }

(parse.y)
</pre>

在嵌入动作中，`lex_strterm`作为`tSTRING_DBEG`的值被保存起来(实际上是压入堆栈)，并在常规动作中返回（退栈）。
这是个相当好的办法。

可是为什么要做这么麻烦的事呢？像通常的做法，扫描到“`#{`”再调一次`yyparse()`不就行了吗？实际上这么做有个问题。
`yyparse()`是不能递归调用的。这是`yacc`众所周知的限制。用来传值的`yylval`是一个全局变量，无心的递归会破坏它的值。
`bison`(GNU的`yacc`)有一个称为`%pure_parser`的预处理指令（directive）可以实现递归，但现在的`ruby`并会假定使用`bison`。
因为在现实中，源自BSD的OS和Windows等常常使用的是`byacc`（Berkeley yacc），这样说来，以`bison`作为前提就不太好了。

h4. `lex_strterm`

前面已经看到了，`lex_strterm`的真假在扫描中表示是否处于字符串模式。实际上，它的值也是有意义的。先来看看它的类型。

▼ `lex_strterm`
<pre class="longlist">
  72  static NODE *lex_strterm;

(parse.y)
</pre>

从这里的定义可以看到，其类型是`NODE*`。这是语法树使用的节点类型。第12章《语法树的构建》中会详细说明。
首先，它是一个有三个元素的结构体，再有，它是`VALUE`，无需`free()`，记住这两点就够了。

▼ `NEW_STRTERM()`
<pre class="longlist">
2865  #define NEW_STRTERM(func, term, paren) \
2866          rb_node_newnode(NODE_STRTERM, (func), (term), (paren))

(parse.y)
</pre>

这个宏用以新建一个保存`lex_strterm`的结点。`term`是字符串的分界符。比如，如果是`"`字符串，就是`"`。如果是`'`字符串，就是`'`。

`paren`保存`%`字符串中括号里面的内容。比如：

<pre class="emlist">
%Q(..........)
</pre>

`paren`中以`'('`表示开始，因此，`term`要以`')'`表示结束。`%`字符串以外的情况，`paren`是0。

最后是`func`，表示字符串的种类。可以使用的种类有以下几种。

▼ `func`
<pre class="longlist">
2775  #define STR_FUNC_ESCAPE 0x01  /* \n之类的反斜杠有效 */
2776  #define STR_FUNC_EXPAND 0x02  /* 嵌入式有效 */
2777  #define STR_FUNC_REGEXP 0x04  /* 正则表达式 */
2778  #define STR_FUNC_QWORDS 0x08  /* %w(....)或是%W(....) */
2779  #define STR_FUNC_INDENT 0x20  /* <<-EOS(结束符可缩进) */
2780
2781  enum string_type {
2782      str_squote = (0),
2783      str_dquote = (STR_FUNC_EXPAND),
2784      str_xquote = (STR_FUNC_ESCAPE|STR_FUNC_EXPAND),
2785      str_regexp = (STR_FUNC_REGEXP|STR_FUNC_ESCAPE|STR_FUNC_EXPAND),
2786      str_sword  = (STR_FUNC_QWORDS),
2787      str_dword  = (STR_FUNC_QWORDS|STR_FUNC_EXPAND),
2788  };

(parse.y)
</pre>

也就是说，`enum string_type`中的各项意义如下：

|`str_squote`|`'`字符串/`%q`|
|`str_dquote`|`"`字符串/`%Q`|
|`str_xquote`|命令字符串(本书没有说明)|
|`str_regexp`|正则表达式|
|`str_sword`|`%w`|
|`str_dword`|`%W`|

h4. 字符串扫描函数

接下来是字符串模式时的`yylex()`，也就是开始的`if`。

▼ `yylex`-字符
<pre class="longlist">
3114      if (lex_strterm) {
3115          int token;
3116          if (nd_type(lex_strterm) == NODE_HEREDOC) {
3117              token = here_document(lex_strterm);
3118              if (token == tSTRING_END) {
3119                  lex_strterm = 0;
3120                  lex_state = EXPR_END;
3121              }
3122          }
3123          else {
3124              token = parse_string(lex_strterm);
3125              if (token == tSTRING_END || token == tREGEXP_END) {
3126                  rb_gc_force_recycle((VALUE)lex_strterm);
3127                  lex_strterm = 0;
3128                  lex_state = EXPR_END;
3129              }
3130          }
3131          return token;
3132      }

(parse.y)
</pre>

基本上分成here document和其他部分。这里不理会`parse_string()`。它的前面有大量的条件存在，
使其变成一段意大利面式的代码。即便举例说明，你也一定发牢骚，“就这样的代码！”
而且，同付出相比，显得索然无趣。

当然，不会完全不说明。在附赠CD-ROM中，解析了每个扫描函数。有兴趣的读者可以看看。

h4. Here Document

和一般的字符串相比，here document有趣多了。和其它的元素不同，它是以“行”为单位的。
而且将起始符号放在程序的中间挺可怕的。先从扫描到here document起始符号的`yylex()`代码开始吧！

▼ `yylex`-`'<'`
<pre class="longlist">
3260        case '<':
3261          c = nextc();
3262          if (c == '<' &&
3263              lex_state != EXPR_END &&
3264              lex_state != EXPR_DOT &&
3265              lex_state != EXPR_ENDARG &&
3266              lex_state != EXPR_CLASS &&
3267              (!IS_ARG() || space_seen)) {
3268              int token = heredoc_identifier();
3269              if (token) return token;

(parse.y)
</pre>

先忽略这个例子中的一堆`lex_state`。这里只读到“`<<`”，剩下的就是用`heredoc_identifier()`做一些扫描。
下面便是`heredoc_identifier()`。

▼ `heredoc_identifier()`
<pre class="longlist">
2926  static int
2927  heredoc_identifier()
2928  {
          /* ……省略……读起始符号 */
2979      tokfix();
2980      len = lex_p - lex_pbeg;   /*(A)*/
2981      lex_p = lex_pend;         /*(B)*/
2982      lex_strterm = rb_node_newnode(NODE_HEREDOC,
2983                          rb_str_new(tok(), toklen()),  /* nd_lit */
2984                          len,                          /* nd_nth */
2985          /*(C)*/       lex_lastline);                /* nd_orig */
2986
2987      return term == '`' ? tXSTRING_BEG : tSTRING_BEG;
2988  }

(parse.y)
</pre>
	
读开始符号(`<<EOS`)怎么做都可以，这里就省略了。到这里，输入缓冲应该如图10所示。
还记得输入缓冲是以行为单位吧！

!images/ch_parser_lexparams.png(`"printf(<<EOS, n)"`的扫描)!

`heredoc_identifier()`所做的事情如下。
（A）`len`是读入行中的字节数。
（B）`lex_p`一下指到了行尾。
也就是说，读入行中的起始符号之后的部分被忽略了。那剩下部分什么时候解析呢？
（C）将`lex_lastline`（读入行）和`len`（已经读到的长度）保存下来暗示了这个神秘问题的答案。

`heredoc_identifier()`前后的动态调用图可以简单地表示如下。

<pre class="emlist">
yyparse
    yylex(case '<')
        heredoc_identifier(lex_strterm = ....)
    yylex(开始的if)
        here_document
</pre>

这个`here_document()`用以扫描here document的正文。下面是`here_document()`，忽略了异常情况，
并加了注释。请注意，`lex_strterm`是在`heredoc_identifier()`里赋值的。

▼ `here_document()`(简化版)
<pre class="longlist">
here_document(NODE *here)
{
    VALUE line;                      /* 扫描中的行 */
    VALUE str = rb_str_new("", 0);   /* 保存结果的字符串 */

    /* ……异常处理，省略…… */

    if (表达式中的嵌入表达式) {
        do {
            line = lex_lastline;     /*(A)*/
            rb_str_cat(str, RSTRING(line)->ptr, RSTRING(line)->len);
            lex_p = lex_pend;        /*(B)*/
            if (nextc() == -1) {     /*(C)*/
                goto error;
            }
        } while (扫描中的行不是结束符号);
    }
    else {
        /* 表达式中的嵌入表达式有效的情况……略 */
    }
    heredoc_restore(lex_strterm);
    lex_strterm = NEW_STRTERM(-1, 0, 0);
    yylval.node = NEW_STR(str);
    return tSTRING_CONTENT;
}
</pre>

`rb_str_cat()`是在Ruby字符串结尾连上`char*`的函数。也就是说，（A）读入行`lex_lastline`连接到`str`。
连号后，这一行就结束了。（B）`lex_p`一下指到了行尾。（C）有些问题，看起来，这里是在做结束检查，
而实际上是读入下一行。希望记住，`nextc()`的规范是一行读完后便会去读下一行。
正式因为（B）强行结束了一行，所以，（C）将`lex_p`指向了下一行。

最后是从`do` `while`循环里提取出的`heredoc_restore()`。

▼ `heredoc_restore()`
<pre class="longlist">
2990  static void
2991  heredoc_restore(here)
2992      NODE *here;
2993  {
2994      VALUE line = here->nd_orig;
2995      lex_lastline = line;
2996      lex_pbeg = RSTRING(line)->ptr;
2997      lex_pend = lex_pbeg + RSTRING(line)->len;
2998      lex_p = lex_pbeg + here->nd_nth;
2999      heredoc_end = ruby_sourceline;
3000      ruby_sourceline = nd_line(here);
3001      rb_gc_force_recycle(here->nd_lit);
3002      rb_gc_force_recycle((VALUE)here);
3003  }

(parse.y)
</pre>

`here->nd_orig`中放的是有起始符号的那一行。`here->nd_nth`中放的是起始符号那一行中已经读入的长度。
也就是紧接着开始符号继续扫描，好象什么都没发生过一样。

!images/ch_parser_heredoc.png(here document的扫描分解图)!